---
title: Browser Router와 Hash Router
date: "2023-03-26"
template: "post"
draft: false
slug: "/posts/browser-router-hash-router"
category: "Tech"
tags:
  - "Router"
description: "회사 어드민 프로젝트에 필터 기능을 구현하려고 코드를 뒤적이고 있었는데... 그런데 잠깐, 이 프로젝트는 왜 해시 라우터로 되어 있는거지?"
---

### Hash Router 너는 누구니?

회사 어드민 프로젝트에 필터 기능을 구현하기 위해 쿼리스트링을 열심히 달던 중이였다. 그런데 정말 귀신이 곡할 노릇으로 새로 고침만 하면 쿼리스트링 부분이 홀랑 날아가버렸다. 아니 이게 무슨 일이냐고. (헛짚은거 같긴 한데) 해시 라우터 니가 범인이니? 아니 그런데 잠깐, 이 프로젝트는 도대체 왜 해시 라우터로 되어 있는거지? <br />
(깔깔 포인트: 너무나 당연하게도 해시 라우터는 범인이 아니였다. 그저 어떤 HOC에서 의도치 않게 쿼리스트링을 날려버리는 버그가 있었을 뿐 ^^(...) 잘 해결했다.)

(… 부끄러운 이야기이지만) 나는 이제껏 경험한 React 프로젝트에서는 모두 Browser Router만을 사용했기 때문에 Hash Router는 친숙하지 않았다.
![https://reactrouter.com/en/main/router-components/hash-router](/media/hash-router-not-recommended.png)
 심지어 React Router의 공식 문서에도 강력하게 해시 라우터의 사용을 추천하지 않고 있었다. 그런데 왜 이 프로젝트는 무슨 이유로 브라우저 라우터를 사용하지 않고 해시 라우터를 사용한 것일까? 두 라우터 간의 차이점은 뭘까?

<br /><br />

따라서 나는 여러 가지 글을 읽어 보았고 그 결과 두 라우터가 다음과 같은 특징을 갖고 있음을 알 수 있었다. 
### Browser Router:
Browser Router는 HTML5의 History API를 사용하여 페이지 간의 전환을 처리한다. 이 방식은 실제 URL 경로를 사용하므로 http://example.com/about 과 같은 형태의 URL을 가지는데 주요 특징은 다음과 같다:
* 브라우저 지원: HTML5의 History API를 지원하는 최신 브라우저에서 사용 가능하다다.
* 서버 요청: URL 경로가 변경되면 서버로 요청이 전송된다. 따라서 서버 측에서도 동일한 경로에 대한 응답을 제공해야 한다.
* 깔끔한 URL: 해시(#) 없이 실제 경로를 사용하므로 URL이 깔끔하고 읽기 쉽다.
* 새로 고침시에 에러가 발생하며 이를 해결하기 위해서는 **서버에 추가적인 세팅**이 필요하다. 

### Hash Router:
Hash Router는 URL의 해시(#)를 사용하여 페이지 간의 전환을 처리한다. 예를 들어, http://example.com/#/about 과 같은 형태의 URL을 사용한다. 해시(#)는 URL의 일부로 간주되지만 클라이언트 측에서만 해석되고 서버로의 요청에는 포함되지 않는다. 이는 웹 브라우저의 내장된 기능으로 이러한 특징으로 인해 서버 측에서는 항상 동일한 페이지를 반환하게 된다. 주요 특징은 다음과 같다:
* 브라우저 지원: 모든 최신 브라우저에서 사용 가능하다.
* 서버 요청: 해시가 변경되어도 서버로 요청이 전송되지 않는다. 즉, 클라이언트 측에서만 라우팅이 처리된다.
* SEO에 취약: 해시 라우터를 사용하면 여러 페이지가 동일한 기본 URL을 공유하게 된다. 예를 들어, `http://example.com/#/about` 과 `http://example.com/#/contact` 라는 두 개의 페이지는 실제로는 동일한 기본 URL인 `http://example.com/`을 공유한다. 이로 인해 검색 엔진은 각각의 페이지를 별개의 인덱스로 처리하기 어려울 수 있다.
* 호환성: 구형 브라우저와 호환되는 라우팅 방식이다.
* 새로 고침해도 에러가 발생하지 않는다. 


대부분의 항목에서 고개를 끄덕이며 읽어 내려오는데, 한 가지 특징에서 의문이 들었다. **Browser Router를 사용하면 새로 고침시에 에러가 난다**고? 왜?

이제까지 내가 경험했던 React 기반 프로젝트에서는 React-Router-Dom의 Browser Router를 사용했으나 새로 고침시에 에러가 나는 현상을 만나지 못했는데... 그럼 내가 썼던 Browser Router는 무엇이었을까? (…) 나도 모르게 누군가가 추가적인 세팅을 해 주었던 것일까? (코드 우렁각시라도 있는 것일까 🥺?) 그 `**추가적인 세팅**이란 과연 무엇일까?

<br /><br />

### Browser Router를 사용하면 새로 고침시에 에러가 난다던데… 🤔
우선 Browser Router 를 사용하면 왜 새로 고침시에 에러가 발생 하는지 근본적인 원인을 살펴보고자 했다.

MPA(Multi page Application)으로 구현된 웹사이트의 경우, 경로를 이동하면 다음과 같은 동작을 하게 된다.
- 유저가 www.example.com/about 페이지로 이동을 한다.
- 서버에 GET 요청을 보내 `about.html` 을 받아온다.
- 브라우저는 `about.html` 이용해 화면을 그린다.

즉, 이 MPA에서 `새로운 화면을 보여준다는 것은 = 새로운 html 파일을 받아온다`, 이며 이것은 곧 새로 고침과 같은 효과(현상)가 나타나는 것이다. 새로운 페이지를 보기 위해서는 새로고침(과 같은 효과)가 일어나야만 했으며 새로운 html 페이지를 받아올 때까지 하얗게 날아간 화면을 봐야만 했다.
<br />

SPA(Single Page Application) 프레임워크들이 대두되고 CSR을 하게 되면서 라우팅의 동작 방식이 변하게 된다. SPA는 html은 한번만 받아오고 나머지 화면을 전부 JS로 그리는 형태이다. 따라서 SPA / CSR 상황에서 페이지 이동(라우팅)이 일어날 때는 다음과 같이 동작한다.

- 브라우저 경로를 변경하면 트리거 되는 기본 HTML GET 요청(ex. `/about`으로 이동하면 about.html을 서버에 요청하는 것)은 막되
- 브라우저 주소는 변경된 상태를 유지하도록 한 다음
- 변경을 감지하여 DOM API가 다른 페이지에 알맞은 화면을 그리도록 한다.
<br />

React에서는 다음과 같이 동작할 것이다.
* React(SPA / CSR)로 구현된 웹 사이트의 홈페이지에 접속하면 서버에 요청하여 index.html 파일을 받아온다. 이 때 index.html 의 body 부분은 비어있다. 
* 브라우저는 HTML 파일에서 head 태그를 읽으며 추가로 필요한 자원(ex. index.js, index.css 등)을 서버로 다시 요청한다.
* 버튼을 눌러 다른 페이지로 이동할 경우(ex. /about) 서버에 about.html이 아닌 about.js 파일을 요청해 받아온다. 그리고 기존에 받아 놓았던 index.html에 about.js로 새로운 페이지를 그린다.

앞서 말했듯이 about.html 을 받아오는 기본 동작을 막고, about.js파일을 받아 DOM API가 `/about`에 알맞는 화면을 그리게 된다. 즉 path 이동과 routing은 작동을 하지만 모든 것이 클라이언트 사이드에서 이뤄지고 서버는 아무런 관계가 없다.
<br />

해당 사이트를 사용하는 모든 유저가 무조건 홈페이지(`/`)로 처음 접속하여 버튼을 눌러서만 이동 한다면, 전혀 문제 될 것이 없다. 모든 라우팅은 앞서 말한 CSR의 방식으로 동작할 것이기 때문이다. 하지만 유저가 항상 이렇게 행동할 것이라고 누구도 장담 할 수 없다. 누군가는 버튼을 눌러 의도적인 새로 고침을 유도할 것이고, 누군가는 인덱스 페이지가 아닌 다른 페이지(ex. /about) 주소를 주소창에 직접 입력하여 바로 접근하고 싶어할 것이다.
<br />

**그럼 유저가 홈페이지가 아닌 페이지에서 의도적으로 새로고침을 트리거하거나, 주소를 직접 쳐서 들어오게 되면 어떻게 될까?**
* 클라이언트는 서버에 새롭게 파일을 요청하게 된다.
* 이 때, 이미 URL은 react-router의 path로 얼룩져 있는 상태이기 때문에, 서버는 그것이 무엇을 반환해 달라는 말인지 알지 못한다. (새로고침을 하거나 해당 주소를 직접 치는 행위는 index.html을 받아오는 행위가 아니기 때문에…)
* 따라서 서버는 404 not found 에러를 반환한다.

> 바로 이 포인트가 **Browser Router를 이용하면, 새로고침 시에 에러가 난다!** 는 것이다.

### 그렇다면 Browser Router에서 새로고침 시에 에러가 나는 현상을 해결하려면 어떻게 해야 할까?

이를 **해결하는 방법은 크게 2가지** 이다.

1. 라우터를 Hash Router로 변경한다.
2. 서버에서 404 페이지에 대해서 작업한다.
   <br />

#### 1) Hash Router로 변경한다.

- hash router의 경우 URL이 `www.domain.com/#/path**` 과 같은 형태로 이루어지는데, URL의 해시 부분은 서버에 전송되지 않고 브라우저에서만 사용된다.
- 따라서 서버는 해시값을 제외한 www.domain.com에한 요청만 받아 들이게 되므로 index.html을 반환한다.
- 에러가 발생하지 않는다.
- 클라이언트에서는 해시값을 이용해서 라우팅 한다. (클라이언트에서 해시값에 해당하는 페이지가 없을 경우 index.html 만이 노출된다. 빈페이지 같은 것..)

hash router에서 서버는 주소의 이동을 모르게 된다 → 즉 페이지 존재유무에 대해서 모른다, 이로 인한 효과로 검색 엔진이 읽지 못하게 된다.

#### 2) 서버에서 404 페이지에 대한 작업을 한다.

`/`이외의 path로 서버에 요청할 때 무조건 서버가 무조건 index.html을 리턴하도록 설정해준다. 이 방법이 글 초반에 언급한 `서버의 추가적인 세팅`이다.
<br />

### 생각해보니

회사의 어드민 서비스의 경우에는 사내에서만 사용하는 작은 서비스이기 때문에 굳이 서버를 따로 구축하지 않았다. nginx를 이용중이였기 때문에 새로 고침시의 에러를 막기 위해서 해시라우터를 사용한 것이였다. 또한 회사 내부의 어드민 서비스이기 때문에 SEO도 고려할 필요가 없었다. 브라우저 라우터와 해시 라우터의 근본적인 동작 원리를 알아보고 나니, 왜 어드민에 해시 라우터를 사용했는지 명쾌하게 이해되었다. 사실 이제서야 이런 부분에 대해서 이해하게 되었다는 것이 조금 부끄럽기도 하다.

부끄럽고 안타깝게도(?) 나는 이제껏 AWS의 CloudFront나 EC2등을 사용해 직접 배포 세팅을 해본 적이 없었다. 만약 내가 한번이라도 이런 세팅을 한 경험이 있었다면 그 과정에서 라우터나 새로고침에러 등에 대해 진작에 고려해볼 계기가 되지 않았을까 하는 생각이 들었다. AWS를 이용한 배포를 해보지 못한게 항상 마음 속 퀘스트처럼 남아있었는데 (물론 AWS 이용한 배포만이 능사는 아니겠지만...) 꼭 근 시일내에 AWS를 이용한 배포를 경험해 보아야 겠다는 생각이 든다.
