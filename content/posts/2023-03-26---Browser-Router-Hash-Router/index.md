---
title: Browser Router와 Hash Router
date: "2023-03-26"
template: "post"
draft: false
slug: "/posts/browser-router-hash-router"
category: "Tech"
tags:
  - "Router"
description: "회사의 어드민 프로젝트 중 하나가 Hash Router로 구성되어 있었는데, 해당 프로젝트를 다뤄야 하는 일이 생겼다. 그런데, 이 프로젝트는 왜 Hash Router로 되어 있는거지?"
---

### Hash Router가 도대체 뭔데?

회사의 어드민 프로젝트 중 하나가 Hash Router로 구성되어 있었는데, 해당 프로젝트를 다뤄야 하는 일이 생겼다. 도대체 이 프로젝트는 왜 Hash Router로 되어 있는거지? (…부끄러운 이야기이지만) 나는 이제까지의 React 프로젝트 대부분에서 Browser Router만을 사용했기 때문에 Hash Router는 친숙하지 않았다. 도대체 이 프로젝트는 왜 Hash Router로 되어 있는걸까? Browser Router와 Hash Router의 차이는 뭘까?
<br />

여러 자료들을 참고해보니 Hash Router와 Browser Router는 다음과 같은 특징을 갖고 있었다.

#### Browser Router

- HTML5의 history API를 활용해서 UI 업데이트를 한다. (→ 새로고침 없이 URL 경로를 업데이트 할 수 있다)
- 동적인 페이지에 적합하다. (서버에 있는 데이터들을 스크립트에 의해 가공 처리한 후 생성되어 전달되는 웹페이지)
- 새로고침하면 경로를 찾지 못해서 에러가 난다. (주소를 사용하여 페이지를 찾아갈 때도 에러 발생)
- 이를 해결하기 위해서는 `서버에 추가적인 세팅`이 필요하다. 페이지의 유무를 서버에 알려줘야 하며 서버 세팅시 검색엔진에 신경써야 한다.
- 배포가 좀 더 복잡하다.

#### Hash Router

- URL의 hash를 활용한 라우터이다.
- 주소에 #가 붙는다.
- 정적인 페이지에 적합하다. (미리 저장된 페이지가 그대로 보여지는 웹페이지)
- 검색엔진으로 읽지 못한다. 즉, SEO가 좋지 않다. (#값 때문에 서버가 읽지 못하고, 서버가 페이지의 유무를 알지 못하기 때문. 그 이유 때문에 거의 사용하지 않는다.)
- URL의 해시부분은 서버에 전송되지 않으므로 브라우저에서만 사용된다.
- (Hash router를 사용하면 URL의 해시 부분과 일치하는 컴포넌트를 렌더링 하도록 설정할 수 있다)
- 새로고침해도 에러가 일어나지 않는다.
  <br />

음 그래그래... 대부분 끄덕끄덕 하면서 읽어 내려오는데, 몇 가지 특징에서 의문이 들기 시작했다. **Browser Router를 사용하면 새로고침 시에 에러가 난다**고? 도대체 왜? 어째서? 그렇게 되는 것일까🤔??

이제까지 내가 경험했던 React 기반 프로젝트 대부분에서는 react-router-dom의 browser router를 사용했으나 새로고침 시에 에러가 나는 현상을 만나지 못했는데... 내가 썼던 Browser Router는 무엇이었을까?
… 그렇다면 나도 모르게 누군가가 추가적인 세팅을 해 주었던 것일까? (코드 우렁각시라도 있는 것일까 🥺?) 그 `추가적인 세팅`이란 과연 무엇일까?
<br />

### Browser Router를 사용하면 새로고침 시에 에러가 난다던데… 🤔
우선 Browser Router 를 사용하면 왜 새로고침 시에 에러가 발생하는 지에 대해 근본적인 원인을 살펴보고자 했다.

과거 MPA(Multi page Application)으로 구현된 웹사이트의 경우, 경로를 이동하면 다음과 같은 동작을 하게 된다.

- 유저가 www.example.com/about 페이지로 이동을 한다.
- 서버에 GET 요청을 보내 `about.html` 을 받아온다.
- 브라우저는 `about.html` 이용해 화면을 그린다.

즉, 이 시절에 `새로운 화면을 보여준다는 것은 = 새로운 html 파일을 받아온다`, 이며 이것은 곧 새로고침과 같은 효과(현상)가 나타나는이다. 새로운 페이지를 보기 위해서는 새로고침(과 같은 효과)가 일어나야만 했으며 새로운 html 페이지를 받아올 때까지 하얗게 날아간 화면을 봐야만 했다.
<br />

그런데 JS가 점점 발전하면서 사람들은 SPA(Single Page Application)를 하게 된다. SPA는 html은 한번만 받아오고 나머지 화면을 전부 JS로 그리는 형태이다. 따라서 SPA / CSR 상황에서 페이지 이동(라우팅)이 일어날 때는 다음과 같이 동작한다.

- 브라우저 경로를 변경하면 트리거 되는 기본 HTML GET 요청(ex. `/about`으로 이동하면 about.html을 서버에 요청하는 것)은 막되
- 브라우저 주소는 변경된 상태를 유지하도록 한 다음
- 변경을 감지하여 DOM API가 다른 페이지에 알맞은 화면을 그리도록 한다.
<br />

그리고 잘 알다시피 React 는 SPA로 동작하는 대표 라이브러리이다. 
* React(SPA / CSR)로 구현된 웹 사이트의 홈페이지에 접속하면 서버에 요청하여 index.html 파일을 받아온다. 이 때 index.html 의 body 부분은 비어있다. 
* 브라우저는 HTML 파일에서 head 태그를 읽으며 추가로 필요한 자원(ex. index.js, index.css 등)을 서버로 다시 요청한다.
* 버튼을 눌러 다른 페이지로 이동할 경우(ex. /about) 서버에 about.html이 아닌 about.js 파일을 요청해 받아온다. 그리고 기존에 받아 놓았던 index.html에 about.js로 새로운 페이지를 그린다.

앞서 말했듯이 about.html 을 받아오는 기본 동작을 막고, DOM API가 /about에 알맞는 화면을 그리게 된다. 즉 path 이동과 routing은 작동을 하지만 모든것이 클라이언트 사이드에서 이뤄지고 서버는 아무런 관계가 없다. CSR이 이뤄진 것이다.
<br />

해당 사이트를 사용하는 모든 유저가 무조건 홈페이지(`/`)로 처음 접속하여 버튼을 눌러서만 이동한다면, 전혀 문제 될 것이 없다. 모든 라우팅은 앞서 말한 CSR의 방식으로 동작할 것이기 때문이다. 하지만 유저가 항상 이렇게 행동할 것이라고 누구도 장담 할 수 없다. 누군가는 새로고침 버튼을 눌러 의도적인 새로고침을 유도할 것이고, 누군가는 홈페이지가 아닌 다른 페이지(ex. /about) 주소를 주소창에 직접 입력하여 바로 접근하고 싶어할 것이다.
<br />

**그럼 유저가 홈페이지가 아닌 페이지에서 의도적으로 새로고침을 트리거하거나, 주소를 직접 쳐서 들어오게 되면 어떻게 될까?**
* 클라이언트는 서버에 새롭게 파일을 요청하게 된다.
* 이 때, 이미 URL은 react-router의 path로 얼룩져 있는 상태이기 때문에, 서버는 그것이 무엇을 반환해 달라는 말인지 알지 못한다. (새로고침을 하거나 해당 주소를 직접 치는 행위는 index.html을 받아오는 행위가 아니기 때문에…)
* 따라서 서버는 404 not found 에러를 반환한다.

> 바로 이 포인트가 **Browser Router를 이용하면, 새로고침 시에 에러가 난다!** 는 것이다.
> <br />

### 그렇다면 Browser Router에서 새로고침 시에 에러가 나는 현상을 해결하려면 어떻게 해야 할까?

이를 **해결하는 방법은 크게 2가지** 이다.

1. 라우터를 Hash Router로 변경한다.
2. 서버에서 404 페이지에 대해서 작업한다.
   <br />

#### 1) Hash Router로 변경한다.

- hash router의 경우 URL이 `www.domain.com/#/path**` 과 같은 형태로 이루어지는데, URL의 해시 부분은 서버에 전송되지 않고 브라우저에서만 사용된다.
- 따라서 서버는 해시값을 제외한 www.domain.com에한 요청만 받아 들이게 되므로 index.html을 반환한다.
- 에러가 발생하지 않는다.
- 클라이언트에서는 해시값을 이용해서 라우팅 한다. (클라이언트에서 해시값에 해당하는 페이지가 없을 경우 index.html 만이 노출된다. 빈페이지 같은 것..)

hash router에서 서버는 주소의 이동을 모르게 된다 → 즉 페이지 존재유무에 대해서 모른다, 이로 인한 효과로 검색 엔진이 읽지 못하게 된다.

#### 2) 서버에서 404 페이지에 대한 작업을 한다.

`/`이외의 path로 서버에 요청할 때 무조건 서버가 무조건 index.html을 리턴하도록 설정해준다. 이 방법이 글 초반에 언급한 `서버의 추가적인 세팅`이다.
<br />

### 생각해보니

회사의 어드민 서비스의 경우에는 사내에서만 사용하는 작은 서비스이기 때문에 굳이 서버를 따로 구축하지 않았다. nginx를 이용중이였기 때문에 새로 고침시의 에러를 막기 위해서 해시라우터를 사용한 것이였다. 또한 회사 내부의 어드민 서비스이기 때문에 SEO도 고려할 필요가 없었다. 브라우저 라우터와 해시 라우터의 근본적인 동작 원리를 알아보고 나니, 왜 어드민에 해시 라우터를 사용했는지 명쾌하게 이해되었다. 사실 이제서야 이런 부분에 대해서 이해하게 되었다는 것이 조금 부끄럽기도 하다.

부끄럽고 안타깝게도(?) 나는 이제껏 AWS의 CloudFront나 EC2등을 사용해 직접 배포 세팅을 해본 적이 없었다. 만약 내가 한번이라도 이런 세팅을 한 경험이 있었다면 그 과정에서 라우터나 새로고침에러 등에 대해 진작에 고려해볼 계기가 되지 않았을까 하는 생각이 들었다. AWS를 이용한 배포를 해보지 못한게 항상 마음 속 퀘스트처럼 남아있었는데 (물론 AWS 이용한 배포만이 능사는 아니겠지만...) 꼭 근 시일내에 AWS를 이용한 배포를 경험해 보아야 겠다는 생각이 든다.
