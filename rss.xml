<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Eunsonny's Blog]]></title><description><![CDATA[Eunsonny's Blog]]></description><link>http://github.com/dylang/node-rss</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 16 May 2023 16:41:54 GMT</lastBuildDate><item><title><![CDATA[유치한 마음]]></title><description><![CDATA[오롯이 나만의 공간에서]]></description><link>https://eunsonny.github.io/posts/childish-mind</link><guid isPermaLink="false">https://eunsonny.github.io/posts/childish-mind</guid><pubDate>Wed, 03 May 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 블로그는 오롯이 나를 위한 공간이다. 그래서 이 공간에 기술과 개발에 관한 이야기 이외에 개인적인 글도 많이 남겨보려 한다. 사실 개인적인 생각을 글로 남기는 거에 익숙하지 않아서 이게 얼마나 지속될 수 있을지는 잘 모르겠지만(…)&lt;/p&gt;
&lt;p&gt;최근에는 책을 자주 읽고 있다(아니 읽으려고 노력하고 있다, 가 더 적합하려나?). 개발 서적을 제외하고 직접 읽고 싶은 책을 골라 읽는 것이 얼마만인지 모르겠다. 비는 시간만 있으면 맨날천날 핸드폰만 붙잡고 슬롯머신 당기듯 무의미하게 피드 업데이트나 하고 있는 내 모습이 너무 꼴 보기가 싫어서 다른 집중할 만 한 걸 찾은 게 책이다. 아마 이전 같았으면 예능이나 넷플릭스 같은 걸 볼텐데 무슨 이유인지 모르겠지만 최근에는 영상을 집중해서 오래 보기가 어렵다. 알록달록한 화면이 내가 원하지 않아도 시선을 잡아끄는 것이 오히려 불쾌하게 느껴졌다.&lt;/p&gt;
&lt;p&gt;음 어릴 적에는 책을 고르면 주로 추리소설을 골라 읽었다. 마지막 반전이 딱! 범인이 짠! 하면 헉! 하면서 머리가 띵해지는 충격이 좋았다. 뭐 꼭 추리소설이 아니어도 주로 소설책을 골랐다. 그때의 나는 수필류의 글을 기승전결도 없이 밍숭맹숭한 글이라고 생각했고 그래서 손이 잘 안 갔던 것 같다. 딱히 뭔가 말하고자 하는 주제가 있는 것 같지도 않고?&lt;/p&gt;
&lt;p&gt;그런데 요즘 골라 읽는 책은 다 에세이다. 읽고 싶은 책 목록에도 에세이나 인문학책을 위주로 담아놨다. 요즘은 수필이 무엇인가 특별히 말하고자 하는 게 없는 것 같아서 좋다. 단어 이면에 숨어 있는 뜻을 찾으려 노력할 필요도 없고 글자는 그냥 글자로 읽으면 된다. (작가는 무언가를 말하고자 하는 게 있을 수도 있겠지만 적어도 나는 단순하게 읽고 있다.)&lt;/p&gt;
&lt;p&gt;그냥… 내 기분 탓인지 모르겠지만 글은 다른 어떤 것들에 비해서 더 솔직한 느낌이다. 그래서 누군가가 SNS에 올려둔 백 장의 사진을 보는 것보다 진솔하게 쓰인 한 편의 글을 보는 것이 그 사람에 대해 더 잘 알 수 있다고 생각한다. 글은, 글자는 그런 힘이 있다. 꼭 타인에게 읽혀지기 위해 쓰는 글이 아니어도 나 스스로에게 솔직해질 수 있는 방법이기도 하다.&lt;/p&gt;
&lt;p&gt;나는 그걸 알면서도 개인적인 생각을 글로 잘 남기지 않는 편이었다. 만약 내가 글을 남긴다고 하면 크게 둘 중 하나의 공간으로 일 텐데 하나는 SNS같이 지인들 그리고 불특정 다수가 내 글을 볼 수 있는 공간 이거나 아니면 나 혼자만 볼 수 있는 일기장이거나? SNS같이 공개된 곳은 정말 의식적으로 개인적인 생각 남기기를 꺼렸다. 글재주가 없어서 내가 하고 싶은 말을 제대로 쓰지도 못할 것 같았고 내 속내를 까 보일 진짜 솔직한 글을 쓸 자신도 없었다. 그래서 이것저것 발라내고 나면 결국 남는건 밑도 끝도 없이 ’아 힘들다’ 식의 궁금증 유발형 관종 글이 탄생하고 마는데 이건 더더욱 쓰고 싶지 않았고. 그리고 대부분의 사람들은 이런 타인의 글에 별 관심이 없다는 걸 이미 알고 있었기 때문에.&lt;/p&gt;
&lt;p&gt;사실 그러면 그냥 내 일기장에 혼자 쓰고 혼자 보면 될 일인데 나는 그것도 잘 안 했다. 귀찮음이 가장 큰 이유긴 했지만서도 아마 혼자 보는 글도 쓰지 않은 이유는, 사실은, 아주 모순적이게도 누군가가 내 글을 읽어 주길 간절히 바랬기 때문이다. 아주 솔직하게 그렇다.&lt;/p&gt;
&lt;p&gt;마음속 깊이 누군가가 내 이야기를 궁금해하기를, 나에게 물어주기를, 나를 읽어 주기를 무척이나 바랬다. 그냥 피드 속에 흘러가는 글이 아니라 나를 진심으로 알고 싶어 하기를, 그러면 나는 진솔한 나를 차근차근 꺼내 보일 준비가 되어 있었다고, 그리고 내가 바랬듯이 너를 궁금해하고 너한테 묻고 너를 아주 샅샅이 읽어주어야지 하고, 네가 말하지 않아도 내가 먼저 알아주겠다고&lt;/p&gt;
&lt;p&gt;지금도 이 모순적이고 유치한 마음을 지우지 못해서 이곳에 글을 쓰는 거다. 여기는 오롯이 나를 위한 공간이고 누구나 들어올 수 있고 누구나 볼 수 있지만 일부러 찾아오지 않으면 볼 수 없는 곳이니까. 간혹 우연은 있을 수 있겠지만서도.&lt;/p&gt;
&lt;p&gt;누가 이 글을 보아줄까? 어떤 이유로 이 글을 보게 되었을까?&lt;/p&gt;
&lt;p&gt;지금 내 속내를 까 보이자면, 정말 솔직하게 요즘의 나는 너무 많이 힘들고, 엉망이다. 수없이 발버둥 치며 지내고 있다.&lt;br /&gt;지낸다기보다 버틴다는 말이 더 정확할 만큼.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[일 잘하는 개발자란?]]></title><description><![CDATA[누구야 나와]]></description><link>https://eunsonny.github.io/posts/who-is-a-good-developer</link><guid isPermaLink="false">https://eunsonny.github.io/posts/who-is-a-good-developer</guid><pubDate>Tue, 25 Apr 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;최근 내가 맡은 회사 프로젝트에 React-Query를 도입하고 그 사용범위를 점차 넓혀가는 작업을 하고 있다. 마이그레이션 작업 자체는 까다롭고 귀찮기도 한데 상당히 재밌게 하고 있다. 아마도 그 이유는 내가 이 기술의 도입을 주도적으로 이끌었기 때문일 것이다. React-Query는 도입해 보고 싶은 기술이긴 했는데 단순히 ‘요즘 다들 많이 쓰니까-‘가 아니라 지금 프로젝트에 구조적인 개선을 가져올 것이라는 합리적인 근거를 기반으로 도입을 결정했다. 나 스스로와 팀원들을 설득하기 위해 ‘왜 도입해야 하는가’에 대해 고민했고 납득할 만한 근거를 찾았다.&lt;/p&gt;
&lt;p&gt;그런데 어쨌거나 저쨌거나 React-Query 마이그레이션 작업은 눈에 보이지 않는 개선이기도 하고, 작업량이 며칠 만에 뚝딱 될만한 양은 아니라 항상 최우선 순위로 작업하는 테스크는 아니다. 기획 &amp;#x26; 마케팅에서 요구하는 변경 사항이나 다른 피쳐 개발이 있으면 그 업무들이 일 순위가 되고 마이그레이션 작업은 잠시 뒤로 밀렸다가 다른 우선순위 작업이 완료되면 다시 마이그레이션 작업을 하는 식으로 틈틈이 하고 있다. 사실 마음 같아서는 진득하니 마이그레이션 업무만 하고 싶다는 생각이 스멀스멀 피어올랐다. 자꾸 업무 컨텍스트가 스위칭 되는 게 피곤하기도 하고…&lt;/p&gt;
&lt;p&gt;이런 업무 루틴 속에서 최근 마케팅팀의 요청으로 했던 우선순위 작업 중 하나가 Facebook pixel 세팅 작업이었다. Facebook pixel은 Facebook을 통해서 우리 서비스에 유입된 사람들의 행동을 트래킹 할 수 있는 유저 트래킹 툴이다. 근데 이거 영, 문서도 불친절한 것 같고, 적용 사례도 잘 안 찾아지고 해서 세팅 작업을 진행하는 내내 귀찮다는 마음이 커졌다. (근데 결과적으로 &lt;a href=&quot;https://github.com/vercel/next.js/tree/canary/examples/with-facebook-pixel&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;요거&lt;/a&gt; 찾아서 잘 세팅했음 😇)&lt;/p&gt;
&lt;p&gt;그리고 생각해 보자구, 내가 이력서를 쓴다고 할 때 “React-Query 도입을 통한 어쩌구 저쩌구…” 한 줄은 쓸지 몰라도, “Facebook pixel 세팅”이라는 한 줄을 쓰게 될까? 이 업무가 나한테 어떤 기술적인 성장이나 깨달음을 주는 것도 아니고 말이야… 흐음’ 뭐 이런 생각들을 하고 있었는데, 순간 이건 지극히 개발만을 위한 개발자의 관점이라는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;내가 만약 마케팅팀이였다면 사실 React-Query가 무엇인지 알 바인가? “트래킹 툴 적용 좀 해주세요” 하면 삼십분 뒤에 “적용 됐습니다”라고 말해주는 개발자랑 일하고 싶지 않을까? 그리고 마케팅팀 입장에서는 그런 개발자가 일 잘하는 개발자로 여겨지지 않을까(다소 비약적이긴 하다만…🤔)? 더 나아가서 만약 마케팅팀이 트래킹 툴에서 얻어진 데이터를 기반으로 더 효율적인 전략을 마련하고 그게 수익 창출로 이어진다면, 회사 입장에서도 그게 일 잘하는 개발자 아닌가?&lt;/p&gt;
&lt;p&gt;… 음 여튼 서론이 길었는데 일 잘하는 개발자는 하드 스킬이 뛰어난 개발자와 동의어가 아니라는 것을 말하고 싶다. 개인마다 생각의 차이는 있겠지만 적어도 나는 그렇게 생각한다. 그런 점에서 나는 그토록 잘하고 싶어 몸부림치면서도 하드 스킬을 키우는 것에만 너무 집중하지 않았는지 스스로를 되돌아볼 필요가 있겠다.&lt;/p&gt;
&lt;p&gt;그런데 일단 나 역시도 그랬고 ‘개발자’라는 역할에 몰입해 일을 하다보면 ‘기술을 위한 개발’에 몰두하게 되는 경우가 많은 것 같다. 하지만 잊지 말아야 할 점은 기술은 목적이 아니라 가치를 실현하기 위한 수단이며, 가치는 사람들이 서비스를 이용함으로써 생길 수 있다는 점이다. 프로 스포츠 선수들에게 관중(팬)이 없다면 그건 그저 공놀이에 그친다. 나는 기술(개발)도 마찬가지라고 생각한다. 제아무리 기술적으로 뛰어난 서비스라고 해도 아무도 사용하지 않는다면 무슨 소용이 있을까? 서비스 위에 기술이 있는 것이 아니라 기술 위에 서비스가 있다는 점을 잊지 말자. 서비스가 생명력을 가지고 있을 때 기술도 그 가치를 더 할 수 있다. 기술을 위한 개발은 사이드 프로젝트나 토이 프로젝트서 충분히 할 수 있다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;​-&lt;br /&gt;
근데 참 아이러니하게도 기술을 위한 개발을 할 때 재밌는 경우가 많은 것 같다(…)
그래서 회사의 상황이나 프로젝트의 성숙도가 ‘기술을 위한 개발을 해야 하는 경우일 때’ 개발자가 몰입해서 일할 수 있는 환경이 쉽게 조성되는 듯 하다. 아니면 서비스를 위한 개발 테스크를 쳐내고 기술을 위한 개발을 고민할 시간이 주어지는 환경이라면 그것도 좋겠다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;​-&lt;br /&gt;
물론 당연히! 서비스를 위한 개발과 기술을 위한 개발이 항상 따로 있는 것은 아니다. 오히려 두 가지가 공존하는 경우가 많고, 최근에 서비스의 유의미한 개선 + 기술적인 깨달음 포인트가 동시에 왔던 테스트는 모바일 웹 뷰 테스크였는데 이것도 조만간 글로 정리해 블로그에 포스팅할 수 있도록 해보아야겠다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;​-&lt;br /&gt;
내가 지금의 업무에 어느 정도 만족을 느끼는 포인트는 조직이 개편되고 내가 메인으로 맡는 프로젝트가 바뀌면서 기술을 위한 개발을 고민할 여유가 조금 생겼고, 시도해 볼 수 있는 환경이 조성됐다는 점이다. 아마 이렇게 조직이 바뀌지 않았다면 이직에 대한 욕구가 훨씬 강렬했을 것이고, 주도적인 성장 포인트를 찾는데에 보다 큰 어려움을 느끼고 있었을 것이다. 내가 지금 할 수 있는 최대한의 것을 하고 최대한의 것을 얻어야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Browser Router와 Hash Router]]></title><description><![CDATA[회사 어드민 프로젝트에 필터 기능을 구현하려고 코드를 뒤적이고 있었는데... 그런데 잠깐, 이 프로젝트는 왜 해시 라우터로 되어 있는거지?]]></description><link>https://eunsonny.github.io/posts/browser-router-hash-router</link><guid isPermaLink="false">https://eunsonny.github.io/posts/browser-router-hash-router</guid><pubDate>Sun, 26 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;hash-router-너는-누구니&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#hash-router-%EB%84%88%EB%8A%94-%EB%88%84%EA%B5%AC%EB%8B%88&quot; aria-label=&quot;hash router 너는 누구니 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Hash Router 너는 누구니?&lt;/h3&gt;
&lt;p&gt;회사 어드민 프로젝트에 필터 기능을 구현하기 위해 쿼리스트링을 열심히 달던 중이였다. 그런데 정말 귀신이 곡할 노릇으로 새로 고침만 하면 쿼리스트링 부분이 홀랑 날아가버렸다. 아니 이게 무슨 일이냐고. (헛짚은거 같긴 한데) 해시 라우터 니가 범인이니? 아니 그런데 잠깐, 이 프로젝트는 도대체 왜 해시 라우터로 되어 있는거지? &lt;br /&gt;
(깔깔 포인트: 너무나 당연하게도 해시 라우터는 범인이 아니였다. 그저 어떤 HOC에서 의도치 않게 쿼리스트링을 날려버리는 버그가 있었을 뿐 ^^(…) 잘 해결했다.)&lt;/p&gt;
&lt;p&gt;(… 부끄러운 이야기이지만) 나는 이제껏 경험한 React 프로젝트에서는 모두 Browser Router만을 사용했기 때문에 Hash Router는 친숙하지 않았다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/45271769c5fe76130557f3d0abd4d1ae/4719e/hash-router-not-recommended.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAeElEQVQI153NOwoDMQwE0D3CSq5CYmwW/7As1m0w5P63mhBV2ZQpXjODNFt4MKIn1GOHVocjMIgIzHzhnDO/+bfP3SaZ8Von1npingOqHSIDvXe01kwpBbVWzDmRUkLOGSJinapijGFj9vB+I8To4X0AEWMnsuJfb1IOTnW0c7iTAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;picture&gt;
          &lt;source
              srcset=&quot;/static/45271769c5fe76130557f3d0abd4d1ae/8ac56/hash-router-not-recommended.webp 240w,
/static/45271769c5fe76130557f3d0abd4d1ae/d3be9/hash-router-not-recommended.webp 480w,
/static/45271769c5fe76130557f3d0abd4d1ae/e46b2/hash-router-not-recommended.webp 960w,
/static/45271769c5fe76130557f3d0abd4d1ae/f37ae/hash-router-not-recommended.webp 1330w&quot;
              sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
              type=&quot;image/webp&quot;
            /&gt;
          &lt;source
            srcset=&quot;/static/45271769c5fe76130557f3d0abd4d1ae/8ff5a/hash-router-not-recommended.png 240w,
/static/45271769c5fe76130557f3d0abd4d1ae/e85cb/hash-router-not-recommended.png 480w,
/static/45271769c5fe76130557f3d0abd4d1ae/d9199/hash-router-not-recommended.png 960w,
/static/45271769c5fe76130557f3d0abd4d1ae/4719e/hash-router-not-recommended.png 1330w&quot;
            sizes=&quot;(max-width: 960px) 100vw, 960px&quot;
            type=&quot;image/png&quot;
          /&gt;
          &lt;img
            class=&quot;gatsby-resp-image-image&quot;
            src=&quot;/static/45271769c5fe76130557f3d0abd4d1ae/d9199/hash-router-not-recommended.png&quot;
            alt=&quot;https://reactrouter.com/en/main/router-components/hash-router&quot;
            title=&quot;https://reactrouter.com/en/main/router-components/hash-router&quot;
            loading=&quot;lazy&quot;
            decoding=&quot;async&quot;
            style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
          /&gt;
        &lt;/picture&gt;
  &lt;/a&gt;
    &lt;/span&gt;
심지어 React Router의 공식 문서에도 강력하게 해시 라우터의 사용을 추천하지 않고 있었다. 그런데 왜 이 프로젝트는 무슨 이유로 브라우저 라우터를 사용하지 않고 해시 라우터를 사용한 것일까? 두 라우터 간의 차이점은 뭘까?&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;여러가지 글을 찾아본 결과 두 라우터가 다음과 같은 특징을 갖고 있음을 알 수 있었다.&lt;/p&gt;
&lt;h3 id=&quot;browser-router&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#browser-router&quot; aria-label=&quot;browser router permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Browser Router:&lt;/h3&gt;
&lt;p&gt;Browser Router는 HTML5의 History API를 사용하여 페이지 간의 전환을 처리한다. 이 방식은 실제 URL 경로를 사용하므로 &lt;code class=&quot;language-text&quot;&gt;http://example.com/about&lt;/code&gt; 과 같은 형태의 URL을 가지는데 주요 특징은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저 지원: HTML5의 History API를 지원하는 최신 브라우저에서 사용 가능하다.&lt;/li&gt;
&lt;li&gt;서버 요청: URL 경로가 변경되면 서버로 요청이 전송된다. 따라서 서버 측에서도 동일한 경로에 대한 응답을 제공해야 한다.&lt;/li&gt;
&lt;li&gt;깔끔한 URL: 해시(#) 없이 실제 경로를 사용하므로 URL이 깔끔하고 읽기 쉽다.&lt;/li&gt;
&lt;li&gt;새로 고침시에 에러가 발생하며 이를 해결하기 위해서는 &lt;strong&gt;서버에 추가적인 세팅&lt;/strong&gt;이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;hash-router&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#hash-router&quot; aria-label=&quot;hash router permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Hash Router:&lt;/h3&gt;
&lt;p&gt;Hash Router는 URL의 해시(#)를 사용하여 페이지 간의 전환을 처리한다. 예를 들어, &lt;code class=&quot;language-text&quot;&gt;http://example.com/#/about&lt;/code&gt; 과 같은 형태의 URL을 사용한다. 해시(#)는 URL의 일부로 간주되지만 클라이언트 측에서만 해석되고 서버로의 요청에는 포함되지 않는다. 이는 웹 브라우저의 내장된 기능으로 이러한 특징으로 인해 서버 측에서는 항상 동일한 페이지를 반환하게 된다. 주요 특징은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저 지원: 모든 최신 브라우저에서 사용 가능하다.&lt;/li&gt;
&lt;li&gt;서버 요청: 해시가 변경되어도 서버로 요청이 전송되지 않는다. 즉, 클라이언트 측에서만 라우팅이 처리된다.&lt;/li&gt;
&lt;li&gt;SEO에 취약: 해시 라우터를 사용하면 여러 페이지가 동일한 기본 URL을 공유하게 된다. 예를 들어, &lt;code class=&quot;language-text&quot;&gt;http://example.com/#/about&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;http://example.com/#/contact&lt;/code&gt; 라는 두 개의 페이지는 실제로는 동일한 기본 URL인 &lt;code class=&quot;language-text&quot;&gt;http://example.com/&lt;/code&gt;을 공유한다. 이로 인해 검색 엔진은 각각의 페이지를 별개의 인덱스로 처리하기 어려울 수 있다.&lt;/li&gt;
&lt;li&gt;호환성: 구형 브라우저와 호환되는 라우팅 방식이다.&lt;/li&gt;
&lt;li&gt;새로 고침해도 에러가 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대부분의 항목에서 고개를 끄덕이며 읽어 내려오는데, 한 가지 특징에서 의문이 들었다. &lt;strong&gt;Browser Router를 사용하면 새로 고침시에 에러가 난다&lt;/strong&gt;고? 왜?&lt;/p&gt;
&lt;p&gt;이제까지 내가 경험했던 React 기반 프로젝트에서는 React Router의 Browser Router를 사용했으나 새로 고침시에 에러가 나는 현상을 만나지 못했는데… 그럼 내가 썼던 Browser Router는 무엇이었을까? (…) 나도 모르게 누군가가 추가적인 세팅을 해 주었던 것일까? (코드 우렁각시라도 있는 것일까 🥺?) 그 `&lt;strong&gt;추가적인 세팅&lt;/strong&gt;이란 과연 무엇일까?&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id=&quot;browser-router를-사용하면-새로-고침시에-에러가-난다던데-&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#browser-router%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%83%88%EB%A1%9C-%EA%B3%A0%EC%B9%A8%EC%8B%9C%EC%97%90-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%82%9C%EB%8B%A4%EB%8D%98%EB%8D%B0-&quot; aria-label=&quot;browser router를 사용하면 새로 고침시에 에러가 난다던데  permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Browser Router를 사용하면 새로 고침시에 에러가 난다던데… 🤔&lt;/h3&gt;
&lt;p&gt;우선 Browser Router 를 사용하면 왜 새로 고침시에 에러가 발생 하는지 근본적인 원인을 살펴보고자 했다.&lt;/p&gt;
&lt;p&gt;MPA(Multi page Application)으로 구현된 웹사이트의 경우, 경로를 이동하면 다음과 같은 동작을 하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유저가 &lt;code class=&quot;language-text&quot;&gt;www.example.com/about&lt;/code&gt; 페이지로 앵커 태그를 통해 이동을 한다.&lt;/li&gt;
&lt;li&gt;URL이 변경되면 서버에 GET 요청을 보내 &lt;code class=&quot;language-text&quot;&gt;about.html&lt;/code&gt; 을 받아온다.&lt;/li&gt;
&lt;li&gt;브라우저는 &lt;code class=&quot;language-text&quot;&gt;about.html&lt;/code&gt; 이용해 화면을 그린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, 이 MPA에서 &lt;code class=&quot;language-text&quot;&gt;새로운 화면을 보여준다는 것은 = 새로운 html 파일을 받아온다&lt;/code&gt;, 이며 새로운 페이지를 보기 위해서는 새로고침(과 같은 효과)가 일어나야만 했다. 따라서 유저들은 새로운 html 페이지를 받아올 때까지 하얗게 날아간 화면을 봐야만 했다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;SPA(Single Page Application) 프레임워크들이 대두되고 CSR을 하게 되면서 라우팅의 동작 방식이 변하게 된다. SPA는 html은 한번만 받아오고 나머지 화면을 전부 JS로 그리는 형태이다. 따라서 SPA / CSR 상황에서 페이지 이동(라우팅)이 일어날 때는 다음과 같이 동작한다(+ 잊지말자 브라우저 라우터 기준이다).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React(SPA / CSR)로 구현된 웹 사이트의 홈페이지(인덱스 페이지)에 접속하면 웹 서버에 요청해 html, CSS, JS 파일을 받아온다.&lt;/li&gt;
&lt;li&gt;유저가 버튼을 눌러 다른 페이지로 이동하려고 하면, History API의 pushState를 이용하여 URL을 변경한다.&lt;/li&gt;
&lt;li&gt;이 때 pushState를 이용하면 URL만을 변경한다. 즉, URL은 변경되지만 웹서버에 요청을 보내지 않는다. (앵커 태그를 이용해 URL을 변경하면 웹브라우저의 내장 기능에 따라 자동으로 웹서버에 요청을 보낸다.)&lt;/li&gt;
&lt;li&gt;클라이언트 단에서 URL의 변경을 감지하여 DOM API가 URL에 알맞는 화면을 그리게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URL의 변경과 라우팅은 이뤄지지만 모든 것이 클라이언트 사이드에서 행해지고 서버는 아무런 관계가 없다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 방식의 라우팅은 해당 사이트를 사용하는 모든 유저가 무조건 홈페이지(인덱스 페이지)(&lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt;)로 처음 접속하여 버튼을 눌러서만 이동 한다면, 문제 될 것이 없다. 인덱스 페이지 URL의 요청을 받은 서버는 필요한 자원을 제공할 것이고 그 다음 라우팅은 앞서 말한 CSR의 방식으로 동작할 것이기 때문이다. 하지만 유저가 언제나 이렇게 행동할 것이라고 누구도 장담 할 수 없다. 누군가는 버튼을 눌러 의도적인 새로 고침을 유도할 것이고, 누군가는 인덱스 페이지가 아닌 다른 페이지(ex. &lt;code class=&quot;language-text&quot;&gt;/about&lt;/code&gt;) 주소를 주소창에 직접 입력하여 바로 접근하고 싶어할 것이다.
&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그럼 유저가 인덱스 페이지가 아닌 페이지에서 의도적으로 새로 고침을 하거나, 주소를 직접 쳐서 들어오려 되면 어떻게 될까?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유저가 &lt;code class=&quot;language-text&quot;&gt;www.example.com/detail&lt;/code&gt; 페이지에서 새로 고침을 시도한다.&lt;/li&gt;
&lt;li&gt;웹브라우저의 내장 기능으로 인해 웹 서버에 파일을 요청하게 된다.&lt;/li&gt;
&lt;li&gt;이 때, 이미 URL은 React Router의 path로 얼룩져 있는 상태이기 때문에, 서버는 그것이 무엇을 반환해 달라는 말인지 알지 못한다. (서버는 인덱스 페이지에 대한 요청에만 무엇을 반환해야 할지 알고 있다.)&lt;/li&gt;
&lt;li&gt;따라서 서버는 404 not found 에러를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 바로 이 부분이 &lt;strong&gt;Browser Router를 이용하면, 새로 고침시에 에러가 난다!&lt;/strong&gt; 는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br /&gt;
&lt;h3 id=&quot;그렇다면-browser-router에서-새로-고침시에-에러가-나는-현상을-해결하려면-어떻게-해야-할까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-browser-router%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C-%EA%B3%A0%EC%B9%A8%EC%8B%9C%EC%97%90-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%82%98%EB%8A%94-%ED%98%84%EC%83%81%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C&quot; aria-label=&quot;그렇다면 browser router에서 새로 고침시에 에러가 나는 현상을 해결하려면 어떻게 해야 할까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그렇다면 Browser Router에서 새로 고침시에 에러가 나는 현상을 해결하려면 어떻게 해야 할까?&lt;/h3&gt;
&lt;p&gt;이를 &lt;strong&gt;해결하는 방법은 크게 2가지&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;라우터를 Hash Router로 변경한다.&lt;/li&gt;
&lt;li&gt;웹서버 세팅 시에 404 페이지에 대해서 작업한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-hash-router로-변경한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-hash-router%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;1 hash router로 변경한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1) Hash Router로 변경한다.&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;hash router의 경우 URL이 &lt;code class=&quot;language-text&quot;&gt;www.domain.com/#/path&lt;/code&gt; 과 같은 형태로 이루어지는데, URL의 해시 부분은 서버에 전송되지 않고 브라우저에서만 사용된다.&lt;/li&gt;
&lt;li&gt;서버는 언제나 해시 값을 제외한 &lt;code class=&quot;language-text&quot;&gt;www.domain.com&lt;/code&gt;에 대한 요청만 받아 들이게 되므로 무엇을 반환해야 하는지 알고 있다.&lt;/li&gt;
&lt;li&gt;따라서 서버 에러가 발생하지 않는다.&lt;/li&gt;
&lt;li&gt;클라이언트에서는 해시 값을 이용해서 라우팅 한다. (클라이언트에서 해시값에 해당하는 페이지가 없을 경우 index.html 만이 노출된다. 빈페이지 같은 것..)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-서버에서-404-페이지에-대한-작업을-한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-404-%ED%8E%98%EC%9D%B4%EC%A7%80%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%91%EC%97%85%EC%9D%84-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;2 서버에서 404 페이지에 대한 작업을 한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2) 서버에서 404 페이지에 대한 작업을 한다.&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt; 이외의 path로 서버에 요청할 때 무조건 서버가 무조건 index.html을 리턴하도록 설정해준다. 이 방법이 글 초반에 언급한 &lt;code class=&quot;language-text&quot;&gt;서버의 추가적인 세팅&lt;/code&gt;이다.&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id=&quot;생각해보니&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EB%8B%88&quot; aria-label=&quot;생각해보니 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;생각해보니&lt;/h3&gt;
&lt;p&gt;브라우저 라우터와 해시 라우터의 근본적인 동작 원리를 알아보고 나니, 왜 어드민에 해시 라우터를 사용했는지 이해되었다. 사내에서만 사용하는 작은 서비스이고 SEO를 고려할 필요도 없기 때문에 따로 추가적인 세팅을 하며 웹서버를 구축하기 보다는 간편하게 해시 라우터를 사용하여 새로 고침 에러를 방지한 것이었다. 사실 이제서야 이런 부분에 대해 이해하게 되었다는 것이 조금 부끄럽기도 하다. 익숙하고 자연스럽다고 생각한 것들에 좀 더 ‘왜’라는 물음표를 자주 띄워야 겠다는 생각이 든다.&lt;/p&gt;</content:encoded></item></channel></rss>