{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/The-problem-that-Streaming-SSR-solves","result":{"data":{"markdownRemark":{"id":"43bb4658-3929-513e-871c-10f010a9cd67","html":"<p>Next.js의 버전이 13.4에 접어들면서 App Router가 stable 상태로 변경되었다. 그렇다고 당장 프로덕션에 적용하기엔 조심스럽지만 이제 더 이상 외면하고 있을 수는 없을 것 같다. App Router를 받아들일 몸(?)과 마음의 준비를 해야 한다. Streaming SSR이 해결하는 문제에 대해서 말한다더니 왜 갑자기 Next.js의 App Router 이야기냐고 🙄? 바로 App Router를 통해 우리는 Streaming SSR에 편하고 빠르게 가까워질 수 있기 때문이다. 그럼 각설하고 본론으로 들어가보자!</p>\n<h2 id=\"csr과-비교했을-때-ssr이-가진-장점\" style=\"position:relative;\"><a href=\"#csr%EA%B3%BC-%EB%B9%84%EA%B5%90%ED%96%88%EC%9D%84-%EB%95%8C-ssr%EC%9D%B4-%EA%B0%80%EC%A7%84-%EC%9E%A5%EC%A0%90\" aria-label=\"csr과 비교했을 때 ssr이 가진 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR과 비교했을 때 SSR이 가진 장점</h2>\n<p>SSR은 서버에서 매번 페이지를 HTML 형태로 완전히 렌더링한 후에 클라이언트로 전송한다. 따라서 자바스크립트의 파싱과 실행 절차 없이 첫 화면을 빠르게 그릴 수 있게 된다. 즉 초기 로딩 시 LCP(Largest Contentful Paint)가 빨라져 사용자들이 페이지의 주요 내용에 더 빨리 접근할 수 있게 해주고, 사용자 경험을 향상시킨다.\n<br /><br /></p>\n<h2 id=\"그럼에도-현재-ssr이-가진-문제점\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC%EC%97%90%EB%8F%84-%ED%98%84%EC%9E%AC-ssr%EC%9D%B4-%EA%B0%80%EC%A7%84-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"그럼에도 현재 ssr이 가진 문제점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼에도 현재 SSR이 가진 문제점</h2>\n<h3 id=\"all-or-nothing-무언가-하기-전에-무엇이든-다-해야-한다\" style=\"position:relative;\"><a href=\"#all-or-nothing-%EB%AC%B4%EC%96%B8%EA%B0%80-%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%93%A0-%EB%8B%A4-%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"all or nothing 무언가 하기 전에 무엇이든 다 해야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>All or Nothing, 무언가 하기 전에 무엇이든 다 해야 한다.</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/913a1/everything-or-nothing.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABA0lEQVQoz42R2W6DMBBF+f/Pq9jMEgVCXgrESwEDtrnVTEWVpg+tpSMZL4c748g5h33fsa4rrLU/oDXCe4/jOKBng3fdM70ZMZgRvRn4ezQPkCsiWQiBL7xCgw45EvqAVt6RyAKZKpGriqF5qkpcZMM/j7ZtYyGNU/I8p3REIOGjgxgqlP0F+VChGGuIoUY+VmjVnSv9JXxN+C10Hld5Q6YqJL1Aogsm1SXeVIarvsFt/xTSvncereogdI1sKBEbwbJYC6YxHRwlpLr/TBgoYUAjOwhZI+upbwVSWXBPYym4hzslpLopJTf/CVo/X/9MOS8zZkssmNYZk/3iw06Ylolf+RP85RrG/1C5hwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/8ac56/everything-or-nothing.webp 240w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/d3be9/everything-or-nothing.webp 480w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/e46b2/everything-or-nothing.webp 960w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/f992d/everything-or-nothing.webp 1440w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/17713/everything-or-nothing.webp 1476w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/8ff5a/everything-or-nothing.png 240w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/e85cb/everything-or-nothing.png 480w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/d9199/everything-or-nothing.png 960w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/07a9c/everything-or-nothing.png 1440w,\n/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/913a1/everything-or-nothing.png 1476w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/b25bc59e8ed1a06e01aeb45b2b78dcaa/d9199/everything-or-nothing.png\"\n            alt=\"everything-or-nothing\"\n            title=\"everything-or-nothing\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<ul>\n<li>유저에게 UI 보여주기 전에 필요한 데이터를 <strong>전부</strong> 다 패치해서 HTML을 그려줘야 한다.</li>\n<li>Hydrate 하기 전에 <strong>모든</strong> 번들을 다 로드해야한다.</li>\n<li>유저 인터랙션이 되기전에 <strong>모든 걸</strong> 다 하이드레이션 해야한다.</li>\n</ul>\n<p>현재 우리가 Next.js나 <code class=\"language-text\">renderToString</code>을 이용해서 하는 SSR의 태생적인 한계점은 렌더링하는 페이지를 기준으로 UI 렌더링, Hydrate, User-Interaction 에 필요한 모든 자원(JS Bundle과 Server Data 등)들과 작업을 한번에 전부 다 준비해야 한다는 점이다.</p>\n<h3 id=\"waterfall-폭포수-현상\" style=\"position:relative;\"><a href=\"#waterfall-%ED%8F%AD%ED%8F%AC%EC%88%98-%ED%98%84%EC%83%81\" aria-label=\"waterfall 폭포수 현상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Waterfall, 폭포수 현상</h3>\n<p>이러한 방식은 Waterfall 현상을 발생 시킨다. 데이터 가져오기(서버) -> HTML로 렌더링(서버) -> 코드 불러오기(클라이언트) -> 하이드레이션(클라이언트). 이 중 그 어떤 단계도 이전 단계가 전체 애플리케이션에 대하여 끝나기 전까진 시작되지 못한다. 이것이 바로 비효율적인 이유다.</p>\n<p>결국 기존 방식의 SSR은 페이지 단위 전체에서 <strong>이뤄지거나, 혹은 이뤄지지 않는 것</strong> 결국 이 2개의 상태만을 가지게 된다. 이 점 때문에 FCP(First Contentful Paint)를 많이 지연시켜, 오히려 유저 경험에 악영향을 주는 경우가 생긴다.\n<br /><br /></p>\n<h2 id=\"streaming-ssr-streaming-html-and-selective-hydration\" style=\"position:relative;\"><a href=\"#streaming-ssr-streaming-html-and-selective-hydration\" aria-label=\"streaming ssr streaming html and selective hydration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Streaming SSR <strong>(Streaming HTML and Selective Hydration)</strong></h2>\n<p>짜잔- 이 문제를 해결하기 위해 등장한게 바로 Streaming SSR으로 기존에 페이지 단위로 준비하던 것을 작게 나눔으로써 해결한다. 즉 기존의 SSR은 <strong>전체의 페이지를 최대한 빨리 준비해서 보여준다</strong>의 방식이였다면, Streaming SSR은 <strong>페이지를 부분으로 작게 쪼개어 준비되는 부분부터 보여준다</strong>의 방식을 택한다.</p>\n<ul>\n<li>\n<p>서버에서 HTML을 스트리밍 형식으로 전달해야 한다. 이렇게 하기 위해서 전통적인 방식의 SSR을 구현할 떄 사용하던 <code class=\"language-text\">renderToString</code> 메소드를 대신해 <a href=\"https://react.dev/reference/react-dom/server/renderToPipeableStream\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"language-text\">renderToPipeableStream</code></a> 메소드를 사용해야 한다.</p>\n</li>\n<li>\n<p>클라이언트에서도 선택적으로 하이드레이션 한다. 이를 위해 클라이언트 단에서 createRoot를 <a href=\"https://github.com/reactwg/react-18/discussions/5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hydrateRoot</a>로 바꿔주고 애플리케이션의 부분 부분을 <code class=\"language-text\">&lt;Suspense></code>로 감싸줘야 한다.</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> hydrateRoot <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom/client'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> App <span class=\"token keyword\">from</span> <span class=\"token string\">'./App.js'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">hydrateRoot</span><span class=\"token punctuation\">(</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">NavBar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Sidebar</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Post</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">RightPane</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>페이지는 Suspense를 경계로 쪼개져 스트리밍 된다. 위의 코드에서는 <code class=\"language-text\">&lt;Comments></code> 항목을 <code class=\"language-text\">&lt;Suspense></code>로 감싸줌으로써, React에게 댓글 부분을 기다리지 않고 나머지 페이지에 대해 HTML을 스트리밍 하도록 할 수 있다. 댓글 부분 대신에 React는 placeholder에 해당하는 <code class=\"language-text\">&lt;Spinner></code> 컴포넌트를 보내준다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 602px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fd78e5f9591acd3cfe7575a605799216/32056/streaming-ssr.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJklEQVQ4y5VUa5OiQAzk//+u/XyrgjIwiK6uwvCYByjqKvRVgudad9bV3VBdGTtJMyZhvKZp0DYtyDaugbMO1loYbaC1hq416qpCXdW8J94ai8a573hjOfZ8PsPrjh1EFmNRfWNeRg/rFyGCQvCe+TL+A0EpsFYbXM4XeKeuQ6rWiIoEsVoizGMIJZGUK+ZoL3LJvrhYQpYpZLFkLilTpPUaqd1gV+1x6k7wDocDtvUO80wgyAXW5egMi5iTQxUjUgkLsLiSzBFEIZHUK+bySo2CrWuw1GtMzQJTu0BcLhFlCWY2ROAizKzAwkm2gY2Ym9qQ/cT5LsJ7GWCrPkHl86ioJDgzY0BSrSB2Ej8qHxM9h28EZjpk+Fpgqhd4rwNMdYhJPfonxRzbYjcKUodIkJLp7bJKUbkan3aPzOXInHpgb3PmdzYbYUZ8mj201aDyeVYbJHqFmREQzZIbMfQD/nfRyLRtC4/mKtUfCJ18CF6vVwz0DAP6YRT/+vpClmecSKsf+ru/59+n02k8IQ3rymxYcNFIhIXE7XrjIEoY7oIU/Pb2BqXUw/dsH4LmLji3MQtGZfJSsO97OOfYvhKkk3ddd//L5gM+jUcjuSm32+1l0q/1zD8L0ik9+h6pKRO9gG8jhKVEf+tfFv534ed1uVzGb5kuhcworOoNPvQWe52zIBe8/7Z/w68TsiAV8ng48lB2hw7d8cjt/xfwDUW3VdtyfWkSfgJNCG8ICdssoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/fd78e5f9591acd3cfe7575a605799216/8ac56/streaming-ssr.webp 240w,\n/static/fd78e5f9591acd3cfe7575a605799216/d3be9/streaming-ssr.webp 480w,\n/static/fd78e5f9591acd3cfe7575a605799216/ff4b8/streaming-ssr.webp 602w\"\n              sizes=\"(max-width: 602px) 100vw, 602px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/fd78e5f9591acd3cfe7575a605799216/8ff5a/streaming-ssr.png 240w,\n/static/fd78e5f9591acd3cfe7575a605799216/e85cb/streaming-ssr.png 480w,\n/static/fd78e5f9591acd3cfe7575a605799216/32056/streaming-ssr.png 602w\"\n            sizes=\"(max-width: 602px) 100vw, 602px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/fd78e5f9591acd3cfe7575a605799216/32056/streaming-ssr.png\"\n            alt=\"streaming-ssr\"\n            title=\"streaming-ssr\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>이 방식을 이용하면 <strong>전통적인 HTML 스트리밍 방식과 다르게 탑다운 순서로 진행될 필요도 없다.</strong></p>\n<ul>\n<li>Suspense를 경계로하여 서버에서 콘텐츠 렌더링이 완료되는 순서대로 클라이언트로 내려보낸다.</li>\n<li>내려보내지는 컨텐츠는 클라이언트가 수신하는대로 즉시 화면에 그려지고 hydrate된다.</li>\n</ul>\n<br />\n<h2 id=\"그래서-결과적으로-어떤게-개선되나요\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EA%B2%B0%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%A4%EA%B2%8C-%EA%B0%9C%EC%84%A0%EB%90%98%EB%82%98%EC%9A%94\" aria-label=\"그래서 결과적으로 어떤게 개선되나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서 결과적으로 어떤게 개선되나요?</h2>\n<ul>\n<li>기존 SSR의 단점으로 여겨지던 늦은 <strong>TTFB(Time To First Byte, 페이지를 요청했을 때 서버에서 데이터의 첫번째 바이트가 도착하는 시점)</strong> 를 당길 수 있게 된다.</li>\n<li><strong>FCP(First Contentful Paint, 페이지가 로드되기 시작하고 컨텐츠의 일부가 화면에 렌더링 될 때 까지의 시간)</strong> 도 개선된다.</li>\n<li>작은 단위로 쪼개어 진행되기 때문에 Hydration 성능도 좋아진다.</li>\n</ul>\n<p>결과적으로 사용자는 빠르게 페이지를 보게 되며, 서버 부하도 분산시킬 수 있게 된다.\n<br /><br /></p>\n<h2 id=\"stream-with-suspense\" style=\"position:relative;\"><a href=\"#stream-with-suspense\" aria-label=\"stream with suspense permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stream with Suspense</h2>\n<p>Streaming SSR에서 Suspense는 굉장히 핵심적인 역할을 담당한다. 지금까지 수차례 ‘작게 나눈다’고 언급했는데 바로 Suspense를 경계로 UI가 나뉘게 되는 것이다.\nSuspense는 비동기 동작을 선언적으로 작성할 수 있게 하는 문법적 설탕 쯤으로 생각했었는데, 이런식으로 활용될 수 있을것이라고는 상상하지 못했다. <code class=\"language-text\">if (isLoading)</code>을 <code class=\"language-text\">&lt;Suspense></code>로 바꾸는 것은 큰 변화가 아닌 것 같지만, 이 과정이 여러 개선점들을 가능하게 해주는 것이다.\n<br /><br /></p>\n<h2 id=\"streaming-ssr-찍먹-가능할까요-\" style=\"position:relative;\"><a href=\"#streaming-ssr-%EC%B0%8D%EB%A8%B9-%EA%B0%80%EB%8A%A5%ED%95%A0%EA%B9%8C%EC%9A%94-\" aria-label=\"streaming ssr 찍먹 가능할까요  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Streaming SSR 찍먹 가능할까요 😋?</h2>\n<p>가능 한지 여부에 대해서 우선 답한다면 ’<strong>YES</strong>’ 다. 그러나 기존에는 Next.js나 Remix와 같이 SSR를 지원하는 프레임워크를 통해 Streaming SSR을 구현하기에는 어려움이 있었다. 따라서 직접 SSR을 위한 서버를 세팅해야 했고 클라이언트에서도 Suspense를 활용하기 위해 Suspense로 감싸진 컴포넌트 내부에서 의도적으로 promise를 throw 하는 동작을 추가해야 하는 번거로움이 있었다.</p>\n<p>하지만 앞으로는 Next.js의 App Router를 이용해 Streaming SSR을 좀 더 간편하게 구현할 수 있을 것으로 보인다. Next.js의 Doc에서 이와 관련한 부분의 <a href=\"https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">글</a>을 참고하면 좋겠다. 또한 컴포넌트 내부에서 의도적으로 Promise를 throw 하는 방식도 React의 use라는 hook을 사용하거나 React Server Component에 async await를 붙여 비동기적으로 렌더링하는 방식 등으로 보다 간편하고 선언적인 형태로 바뀔 것이 예상된다. 단, <a href=\"https://github.com/reactjs/rfcs/pull/229\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">use hook</a>은 아직 RFC에서 논의 중인 단계이고 Server Component 역시 stable한 상태가 아니기 때문에 현재는 실험적인 수준의 찍먹만이 가능할 것으로 보인다. (yummy~😋)\n<br /><br /></p>\n<h4 id=\"글을-마치며-주절주절\" style=\"position:relative;\"><a href=\"#%EA%B8%80%EC%9D%84-%EB%A7%88%EC%B9%98%EB%A9%B0-%EC%A3%BC%EC%A0%88%EC%A3%BC%EC%A0%88\" aria-label=\"글을 마치며 주절주절 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글을 마치며 주절주절</h4>\n<p>사실 Streaming SSR에 대한 글을 쓰게 된건 Next.js의 App router를 뜯어보다가 흘러흘러 오게 된 것이다. 최근 Next.js와 React가 서로 앞서거니 뒷서거니 하며 발맞춰 기능을 업그레이드 하는 모습을 보면 약간 경이로운데(…) 그럼과 동시에 궁금한 것은 이들이 그리는 큰 그림은 과연 어디까지 일까 하는 점이다.</p>\n<p>마치 나는 퍼즐 조각 몇 개를 받아들곤 100피스짜리 퍼즐인 줄 알고 우와- 우와- 하며 열심히 맞추고 있었는데, 알고보니 1000피스를 맞춰야 완성되는 퍼즐인 느낌이랄까? 과연 그들이 그리는 그림은 어떤 모습이고 언제부터 이런 그림을 그려왔던걸까 생각해보면 약간 아득해 지는 느낌이다^^.. 부지런히 설명서를 읽고 퍼즐을 맞춰야 그림의 윤곽을 볼 수 있을 것 같다.</p>\n<h4 id=\"참고자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C\" aria-label=\"참고자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고자료</h4>\n<ul>\n<li><a href=\"https://github.com/reactwg/react-18/discussions/37\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">New Suspense SSR Architecture in React 18</a></li>\n<li><a href=\"https://blog.logrocket.com/streaming-ssr-with-react-18/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">A guide to streaming SSR with React 18</a></li>\n<li><a href=\"https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%98-%EB%AF%B8%EB%9E%98-5b7251bda66d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">(번역)리액트 렌더링의 미래</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=9xl9X2pfHeI\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">스트리밍 SSR 딥 다이브</a></li>\n</ul>","fields":{"slug":"/posts/2023-05-24---Streaming-SSR이-해결하는-문제//posts/The-problem-that-Streaming-SSR-solves","tagSlugs":null},"frontmatter":{"date":"2023-05-24","description":"작게 쪼개볼게요","tags":null,"title":"Streaming SSR이 해결하는 문제","socialImage":null}}},"pageContext":{"slug":"/posts/2023-05-24---Streaming-SSR이-해결하는-문제//posts/The-problem-that-Streaming-SSR-solves"}},"staticQueryHashes":["251939775","2764776372","401334301"]}